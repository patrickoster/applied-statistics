---
title: "R Notes: Writing Functions"
author: "Patrick Oster"
date: "December 28, 2018"
output:
  prettydoc::html_pretty:
    df_print: kable
    highlight: github
    theme: architect
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      results = "hold")
library(tidyverse)
library(knitr)
library(prettydoc)
library(ggthemr)
ggthemr('fresh')
```  

[Home Page](https://patrickoster.github.io/)  

# Functions? Functions.  

Functions are essential in data science for automating repetitive tasks, creating reproducible reports, and generally everything done in R. It is more than likely that a function has been written and uploaded to [CRAN](https://cran.r-project.org/) for whatever your goal is, however, writing functions can be a valuable skill that makes working in R easier.  

```{r, echo = FALSE}
glossary <- data.frame(Term = c("Function", 
                                 "Name", 
                                 "Arguments", 
                                 "Body", 
                                 "return()"),
                        Definition = c("A type of R object",
                                       "Command used to call the function",
                                       "Functional inputs",
                                       "Actions performed on inputs",
                                       "Functional output"))
kable(glossary)
```  

## General Function Structure  
* Functions generally contain four pieces: a name, arguments, a code body, & output  
1. Name: **"my_fun"**  
  + Should be concise while describing what the function does  
  + Function names are assigned like vectors and everything else in R, using "<-", the assignment operator  
2. Arguments: **"(x1, x2)"**  
  + Arguments are function inputs and are defined within parantheses after calling "function"  
  + They can be assigned default values  
    + Ex: **"(x1, x2 = 1)"**  
    + Unless otherwise noted, arg2 will take on the value 1  
3. Body: **"{body}"**  
  + The function body defines the calculations, evaluations, alterations, manipulations or any possible operation to execute using the given arguments  
  + Body operations are conducted in the order they are written starting with the argument inputs; changes to the inputs are inherited from line to line as the body operations are executed  
4. Output  
  + The output is the evaluation of the last expression in the body, unless the *return()* function is used in the function  
    + Explicitly indicating output using the *return()* function in the last line of your function is **best practice**  

```{r}
my_fun <- function (x1, x2) {
  body
}
my_fun()
# Calling this function shows what is going on "under the hood" in R 
# This happens because the body does not utilize the inputs or provide an output
```  

### Super Basic Function Example  
1. Name: **subtract**  
2. Arguments: **(x, y = 1)**  
    + Note that y is defaulted to be 1  
3. Body: **{x - y}**  
    + takes the difference of x & y  
4. Output: **Numeric Value representing the difference of the arguments**  

```{r}
subtract <- function (x, y = 1) {
  x - y
}
# No difference between these expressions because y is given a default value
subtract(1); subtract(x = 1); subtract(x = 1, y = 1)
```  

### Best Practice: using *return()*  
The *return()* function works with most R objects (vectors, lists, data frames, etc.) and forces the function to halt execution and return the provided value or object. Because it tells R to stop executing code, it should be added as the last line of the function body  

```{r}
subtract <- function (x, y = 1) {
  z <- x - y
  return(z)
}
subtract(1); subtract(x = 1); subtract(x = 1, y = 1)
print(paste("Executing subtract(x = 1, y = 2) results in", 
            subtract(x = 1, y = 2), "since y is changed from its default"))
```  

## Scoping  
"Scoping" describes how R searches for values using object names; scoping describes **where** R looks for a value rather than when it looks. In the following example, **c** is being used in 3 ways: first, as a *function* putting the arguments in a vector; second, as a *name*; third, as a *value* which R looks up and identifies as 3.  

```{r}
c <- 5
c(c = c)
```  

## Data Structures  

* Vectors  
  + Properties:  
    + type  
    + length  
  + Types:  
    + **Atomic** vectors are homogenous, i.e. elements must be of the same type  
      + logical  
      + integer  
      + double  
      + character  
      + complex  
      + raw  
    + **Recursive** vectors (lists) can be heterogenous, i.e. lists can contain different types of atomic vectors or other recursive vectors  
      + single brackets (*list[]*) query a sublist  
      + double brackets (*list[[]]*) and dollar signs (*list$*) query elements from within a list  
      + lists are extremely useful in function writing since a variety of vector types can be returned from a function  

## For Loops  
Loops are used to iterate through elements of a data object. For loops generally contain 3 structural pieces: sequence, body & result storage  

1. Sequence: **"(i in 1:length(x))"**  
    + Describes name of index object (i) and values to be iterated over  
2. Body: **"{print(x[i])}"**  
    + Describes the operation to be iterated  
3. Result storage  
    + Identified in the body of the loop  
    + Note that the basic example prints the result of the loop rather than storing it in another object  

### Basic For Loop Example  
```{r}
x <- seq(from = 0, to = 5, by = 1)
for (i in 1:length(x)){
  print(x[i])
}
```  

The *seq_along()* function is useful for identifying values to be iterated over  

```{r}
for (i in seq_along(x)){
  print(x[i])
}
```  

* Before initiating a loop in which the results are being stored, create an empty vector object with sufficient storage space  
* The *vector()* function is useful for creating empty vectors and takes two arguments:  
    + mode (vector type)  
    + length (# of elements in the vector)  

```{r}
result <- vector(mode = "numeric", length = 6L)
for (i in seq_along(x)){
  result[i] <- 2*x[i]
}
result
```  

